# MarketLab — интерактивный тренажёр по микроэкономике на Python

## Оглавление

- [Актуальность проекта](#актуальность-проекта)
- [Общая идея проекта](#общая-идея-проекта)
- [Цель проекта](#цель-проекта)
- [Поддерживаемые темы микроэкономики](#поддерживаемые-темы-микроэкономики)
- [Задачи с множественными режимами (mode)](#задачи-с-множественными-режимами-mode)
- [Генерация задач](#генерация-задач)
- [Генерация тестов и автопроверка](#генерация-тестов-и-автопроверка)
- [Визуализация и обучение через ошибки](#визуализация-и-обучение-через-ошибки)
- [Интерфейс приложения](#интерфейс-приложения)
- [Архитектура приложения](#архитектура-приложения)
- [Пример одной задачи в MarketLab](#пример-одной-задачи-в-marketlab)
- [Почему у задачи несколько тестов](#почему-у-задачи-несколько-тестов)
- [Как формируются множественные тесты](#как-формируются-множественные-тесты)


## Актуальность проекта

На мой взгляд, создание данного web-приложения важно по нескольким причинам.  
Во-первых, всё чаще в современном образовании применяются цифровые технологии, которые позволяют успешнее осваивать материалы курсов по экономике. С этой точки зрения эффективно использование такого инструмента, как web-приложение **«MarketLab»**, поскольку оно будет помогать не только с решением задач, но и с пониманием экономических моделей за счёт визуализации и интерактивных элементов.

Во-вторых, представляется важным совмещение прикладной экономики и языка программирования Python. Это позволяет практиковаться не только в решении экономических задач, но и в разработке алгоритмов, что соответствует современным требованиям к подготовке экономистов и аналитиков. В условиях цифровизации экономики навыки программирования становятся неотъемлемой частью профессиональной подготовки.

---

##  Общая идея проекта

**MarketLab** — это учебное веб-приложение для изучения тем микроэкономики, связанных с **совершенно конкурентным рынком**, через **программирование на Python** и **автоматическую проверку решений**.

По логике работы проект близок к платформам типа **LeetCode**, однако вместо алгоритмов по информатике здесь используются **экономические модели и задачи**.

Ключевая идея проекта заключается в том, что пользователь:
- не решает один частный пример;
- а реализует **универсальный алгоритм**, корректный для целого класса экономических задач.

---

##  Цель проекта

Цель проекта — разработать интерактивную учебную платформу, которая:
- позволяет изучать микроэкономические модели алгоритмически;
- формирует навык программной реализации экономических решений;
- проверяет корректность решений автоматически;
- даёт наглядную визуальную обратную связь.

---

##  Поддерживаемые темы микроэкономики

Проект ориентирован на задачи по совершенно конкурентному рынку, включая:

- поиск рыночного равновесия;
- равновесие при налогах и субсидиях;
- потребительский и производственный излишки (CS, PS);
- совокупное благосостояние и мёртвый груз (DWL);
- агрегирование индивидуальных функций спроса;
- задачи «с конца» (восстановление параметров модели).

Все задачи строятся в рамках **линейных функций спроса и предложения**, что обеспечивает аналитическую решаемость и корректную автопроверку.

---

## Задачи с множественными режимами (`mode`)

Часть задач реализована в формате **множественных режимов**:

- `none` — рынок без вмешательства;
- `tax` — налог на производителей;
- `subsidy` — субсидия производителям.

Режим передаётся входным параметром и влияет на:
- используемую экономическую модель;
- формулы расчёта;
- итоговое равновесие.

Таким образом, пользователь должен писать алгоритм с учётом ветвлений, а не подставлять одну формулу.

---

## Генерация задач

Задачи в системе **генерируются автоматически**.

Для каждой задачи:
- формируется формальная спецификация (модель, цель, параметры);
- параметры выбираются из экономически осмысленных диапазонов;
- проверяется существование корректного равновесия (положительные цена и объём).

На основе формальной спецификации может автоматически формироваться
**красочное жизненное описание задачи** (например, с использованием API нейросети),
которое не влияет на математическую корректность задачи.

---

## Генерация тестов и автопроверка

### Judge-модуль

Проверка решений реализуется через собственный **Judge-модуль**, который:
- запускает пользовательский Python-код в изолированном окружении;
- ограничивает время выполнения и используемые ресурсы;
- прогоняет решение на множестве тестов;
- сравнивает результат с эталонным решением с допустимой погрешностью.

### Публичные и скрытые тесты

Для каждой попытки решения формируется:
- **один публичный тест** — параметры из условия задачи;
- **набор скрытых тестов** (20–30), в которых меняются параметры и режимы.

Скрытые тесты необходимы для проверки универсальности алгоритма и исключения «хардкода».

---

## Визуализация и обучение через ошибки

Проект использует интерактивные графики:
- кривых спроса и предложения;
- точки рыночного равновесия.

При неверном решении пользователь может видеть:
- эталонный график;
- график, построенный на основе его решения;
- визуальное сравнение и подсказки.

Графики выступают не только иллюстрацией, но и инструментом анализа ошибок.

---

## Интерфейс приложения

Приложение состоит из трёх основных страниц:

1. **Главная страница**  
   Описание проекта, целей и принципов работы.

2. **Список задач и прогресс**  
   Каталог задач, фильтры по темам и сложности, статус решений пользователя.

3. **Рабочее окно решения задачи**  
   - жизненное описание задачи;
   - формальная модель;
   - режим (`mode`);
   - интерактивные графики;
   - Python-редактор для написания решения;
   - результат автопроверки.

[По данной ссылке можно посмотреть на динамический макет web-приложения](https://www.figma.com/make/4YwCYJjiDIgaTNg0CXKpyo/%D0%9E%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5?fullscreen=1&t=0kHv18WspbDBiaY7-1)



## Архитектура приложения

### Frontend (Web-интерфейс)

**Используемые технологии:**
- React
- TypeScript
- HTML / CSS
- Monaco Editor (редактор кода, аналогичный VS Code)
- Plotly.js (интерактивные графики)

**Назначение:**
- отображение страниц приложения (главная, список задач, рабочее окно);
- ввод Python-кода пользователем прямо в браузере;
- отправка кода и параметров задачи на сервер;
- визуализация спроса, предложения и равновесия;
- отображение результата автопроверки.

---

### Backend (API-сервер)

**Используемые технологии:**
- Python 3.12
- FastAPI
- Pydantic

**Назначение:**
- генерация задач;
- генерация тестов;
- запуск автопроверки;
- возврат результатов проверки;
- подготовка данных для визуализации.

---

### Генератор задач

**Технологии:**
- Python (отдельный модуль backend)

**Назначение:**
- генерация параметров спроса и предложения;
- проверка экономической корректности параметров;
- формирование формального условия задачи;
- подготовка данных для жизненного описания задачи.

---

### Judge-модуль (автопроверка)

**Технологии:**
- Python
- subprocess или multiprocessing
- ограничения по времени и памяти

**Назначение:**
- запуск пользовательского Python-кода в изолированном процессе;
- проверка решения на множестве тестов;
- сравнение с эталонным решением;
- формирование вердикта проверки.

---

### Визуализация

**Технологии:**
- matplotlib (серверная генерация эталонных данных);
- Plotly.js (клиентская отрисовка).

---

### Хранение данных

**Технологии:**
- SQLite (этап разработки);
- PostgreSQL (при масштабировании).

---

### Генерация текстов условий

**Технологии:**
- API нейросети (например, GigaChat)

**Назначение:**
- автоматическое преобразование формального условия задачи в жизненное описание;
- повышение вовлечённости пользователя без изменения математической модели.

---

## Пример одной задачи в MarketLab

### Тип задачи

Равновесие на совершенно конкурентном рынке с возможным государственным вмешательством.

---

### Формальная модель

Спрос и предложение заданы линейными функциями:

Qd(P) = a − bP  
Qs(P) = c + dP  

где:
- a > 0  
- b > 0  
- d > 0  
- P — цена  
- Q — объём  

---

### Входные данные задачи

Пользователь получает следующие параметры:

- a, b, c, d — параметры модели  
- mode — режим рынка  
- t — величина налога или субсидии (t ≥ 0)  

Допустимые значения параметра mode:
- none — рынок без вмешательства  
- tax — налог на производителей  
- subsidy — субсидия производителям  

---

### Требуемый вывод

Алгоритм должен вернуть:

- равновесную цену  
- равновесный объём  

---

### Экономический смысл режимов

- mode = none  
  Рынок функционирует без государственного вмешательства.

- mode = tax  
  Вводится налог на производителей.  
  Производитель получает цену, уменьшенную на величину налога.

- mode = subsidy  
  Вводится субсидия производителям.  
  Производитель получает цену, увеличенную на величину субсидии.

С точки зрения микроэкономики налог и субсидия создают ценовой клин и эквивалентны вертикальному сдвигу кривой предложения.

---

### Пример публичного теста

Параметры задачи:

- a = 120  
- b = 3  
- c = -10  
- d = 2  
- mode = tax  
- t = 10  

Ожидаемый результат:

- равновесная цена = 30  
- равновесный объём = 30  

---

## Почему у задачи несколько тестов

Если проверять решение только на одном наборе параметров, пользователь может написать код,
который работает лишь для конкретного примера.

Цель MarketLab — проверить универсальный алгоритм, корректный для целого класса задач.
Поэтому каждая задача проверяется на множестве тестов.

---

## Как формируются множественные тесты

### Публичный тест

- параметры совпадают с теми, что показаны в условии;
- используется для прозрачности проверки.

---

### Скрытые тесты

Для каждой попытки решения автоматически формируются от 20 до 30 скрытых тестов.
Параметры скрытых тестов пользователю не отображаются.

---

### Алгоритм генерации тестов

**Шаг 1. Генерация параметров**

- параметр a выбирается положительным  
- параметр b выбирается положительным  
- параметр d выбирается положительным  
- параметр c выбирается из допустимого диапазона  

Это обеспечивает убывающий спрос и возрастающее предложение.

---

**Шаг 2. Выбор режима**

Для каждого теста случайным образом выбирается режим:

- none  
- tax  
- subsidy  

Если выбран режим tax или subsidy, дополнительно выбирается параметр t.

---

**Шаг 3. Проверка экономической корректности**

Для сгенерированных параметров вычисляется равновесие.
Тест принимается только если:

- равновесная цена положительна  
- равновесный объём положителен  

Если условия не выполняются, параметры отбрасываются и генерируются заново.

---

**Шаг 4. Формирование набора тестов**

Для одной пользовательской попытки формируется:

- один публичный тест  
- несколько скрытых тестов с другими параметрами и режимами  

---

### Что проверяет такая схема

- корректный учёт режима задачи  
- правильную реализацию логики равновесия  
- устойчивость алгоритма к изменению параметров  
- невозможность подгонки решения под один пример  

---



## Похожие решения, найденные на просторах интернета:

| 1 | [Maaack / Supply-and-Demand-Simulator](https://github.com/Maaack/Supply-and-Demand-Simulator) |
| 2 | [BrownUniversity / supply-demand-chart-tool](https://github.com/BrownUniversity/supply-demand-chart-tool) |
| 3 | [thonmakerformvp / econ-sim](https://github.com/thonmakerformvp/econ-sim) |
| 4 | [ry-schwartz / stock_analysis_app](https://github.com/ry-schwartz/stock_analysis_app) |
| 5 | [aaronlwan / supply-demand-deep-learning](https://github.com/aaronlwan/supply-demand-deep-learning)|
| 6 | [joshhilton / pyMicroeconomics](https://github.com/joshhilton/pyMicroeconomics) |
